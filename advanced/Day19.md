# Day 19: Quantum Circuit Design Patterns

## üéØ M·ª•c ti√™u
- Hi·ªÉu c√°c pattern thi·∫øt k·∫ø m·∫°ch l∆∞·ª£ng t·ª≠ ph·ªï bi·∫øn
- T·∫°o custom gates v√† circuit composition
- T·ªëi ∆∞u h√≥a m·∫°ch l∆∞·ª£ng t·ª≠
- K·ªπ thu·∫≠t visualization n√¢ng cao

## üîß Circuit Composition Patterns

### 1. Modular Circuit Design

```python
from qiskit import QuantumCircuit, Aer, execute
from qiskit.visualization import plot_histogram, plot_bloch_multivector
from qiskit.quantum_info import Operator
import numpy as np

def create_bell_pair():
    """T·∫°o Bell pair module"""
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.cx(0, 1)
    return qc

def create_ghz_module(n_qubits):
    """T·∫°o GHZ state module"""
    qc = QuantumCircuit(n_qubits, n_qubits)
    qc.h(0)
    for i in range(1, n_qubits):
        qc.cx(0, i)
    return qc

def compose_large_circuit():
    """Compose m·∫°ch l·ªõn t·ª´ c√°c module nh·ªè"""
    qc = QuantumCircuit(4, 4)
    
    # Th√™m Bell pair cho qubit 0,1
    bell_01 = create_bell_pair()
    qc = qc.compose(bell_01, qubits=[0, 1])
    
    # Th√™m Bell pair cho qubit 2,3
    bell_23 = create_bell_pair()
    qc = qc.compose(bell_23, qubits=[2, 3])
    
    # Entangle t·∫•t c·∫£ qubit
    qc.cx(1, 2)
    
    qc.measure(range(4), range(4))
    return qc
```

### 2. Parameterized Circuits

```python
from qiskit.circuit import Parameter

def parameterized_rotation(theta):
    """T·∫°o m·∫°ch v·ªõi tham s·ªë"""
    qc = QuantumCircuit(2, 2)
    qc.ry(theta, 0)
    qc.cx(0, 1)
    qc.ry(theta, 1)
    qc.measure([0, 1], [0, 1])
    return qc

def variational_circuit():
    """Variational quantum circuit"""
    theta = Parameter('Œ∏')
    phi = Parameter('œÜ')
    
    qc = QuantumCircuit(2, 2)
    qc.ry(theta, 0)
    qc.rz(phi, 0)
    qc.cx(0, 1)
    qc.ry(theta, 1)
    qc.measure([0, 1], [0, 1])
    
    return qc

# Bind parameters
def bind_parameters_example():
    qc = variational_circuit()
    bound_circuit = qc.bind_parameters({Parameter('Œ∏'): np.pi/4, Parameter('œÜ'): np.pi/2})
    return bound_circuit
```

## üé® Custom Gates

### 1. T·∫°o Custom Single-Qubit Gate

```python
def create_custom_gate():
    """T·∫°o custom gate t·ª´ ma tr·∫≠n"""
    # Custom gate: sqrt(X) gate
    sqrt_x_matrix = np.array([[1+1j, 1-1j], [1-1j, 1+1j]]) / 2
    
    from qiskit.extensions import UnitaryGate
    sqrt_x_gate = UnitaryGate(sqrt_x_matrix, label='‚àöX')
    
    qc = QuantumCircuit(1, 1)
    qc.append(sqrt_x_gate, [0])
    qc.measure(0, 0)
    return qc

def create_controlled_custom_gate():
    """T·∫°o controlled custom gate"""
    # Custom phase gate
    phase_matrix = np.array([[1, 0], [0, np.exp(1j * np.pi/3)]])
    phase_gate = UnitaryGate(phase_matrix, label='P(œÄ/3)')
    
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.append(phase_gate.control(), [0, 1])
    qc.measure([0, 1], [0, 1])
    return qc
```

### 2. Multi-Qubit Custom Gates

```python
def create_swap_like_gate():
    """T·∫°o gate t∆∞∆°ng t·ª± SWAP nh∆∞ng v·ªõi phase"""
    # Gate: |00‚ü©‚Üí|00‚ü©, |01‚ü©‚Üí|10‚ü©, |10‚ü©‚Üí|01‚ü©, |11‚ü©‚Üíe^(iœÄ/4)|11‚ü©
    matrix = np.array([
        [1, 0, 0, 0],
        [0, 0, 1, 0],
        [0, 1, 0, 0],
        [0, 0, 0, np.exp(1j * np.pi/4)]
    ])
    
    custom_2q_gate = UnitaryGate(matrix, label='SWAP+')
    
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.h(1)
    qc.append(custom_2q_gate, [0, 1])
    qc.measure([0, 1], [0, 1])
    return qc
```

## ‚ö° Circuit Optimization

### 1. Gate Cancellation

```python
def demonstrate_gate_cancellation():
    """Demonstrate gate cancellation optimization"""
    qc = QuantumCircuit(2, 2)
    
    # Th√™m c√°c gate s·∫Ω cancel nhau
    qc.h(0)
    qc.h(0)  # H.H = I
    qc.x(0)
    qc.x(0)  # X.X = I
    
    # Th√™m gate th·ª±c s·ª± c·∫ßn thi·∫øt
    qc.cx(0, 1)
    
    qc.measure([0, 1], [0, 1])
    return qc

def optimize_circuit(qc):
    """Optimize circuit b·∫±ng c√°ch lo·∫°i b·ªè redundant gates"""
    from qiskit.transpiler import PassManager
    from qiskit.transpiler.passes import CommutativeCancellation
    
    pm = PassManager()
    pm.append(CommutativeCancellation())
    optimized_qc = pm.run(qc)
    
    return optimized_qc
```

### 2. Depth Optimization

```python
def create_deep_circuit():
    """T·∫°o m·∫°ch s√¢u ƒë·ªÉ test optimization"""
    qc = QuantumCircuit(3, 3)
    
    # Th√™m nhi·ªÅu layer operations
    for i in range(5):
        qc.h(0)
        qc.cx(0, 1)
        qc.cx(1, 2)
        qc.rz(np.pi/4, 0)
        qc.ry(np.pi/3, 1)
    
    qc.measure(range(3), range(3))
    return qc

def optimize_depth():
    """Optimize circuit depth"""
    qc = create_deep_circuit()
    
    from qiskit.transpiler import PassManager
    from qiskit.transpiler.passes import Depth, Optimize1qGates
    
    pm = PassManager()
    pm.append(Optimize1qGates())
    
    optimized_qc = pm.run(qc)
    
    print(f"Original depth: {qc.depth()}")
    print(f"Optimized depth: {optimized_qc.depth()}")
    
    return optimized_qc
```

## üìä Advanced Visualization

### 1. Bloch Sphere Visualization

```python
def visualize_bloch_sphere():
    """Visualize qubit states tr√™n Bloch sphere"""
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.ry(np.pi/4, 1)
    
    # Kh√¥ng measure ƒë·ªÉ gi·ªØ quantum state
    return qc

def plot_circuit_states():
    """Plot states t·∫°i c√°c ƒëi·ªÉm kh√°c nhau trong circuit"""
    qc = QuantumCircuit(1, 1)
    
    # State 1: |0‚ü©
    qc.h(0)
    
    # State 2: |+‚ü©
    qc.ry(np.pi/4, 0)
    
    # State 3: Superposition
    qc.rz(np.pi/3, 0)
    
    return qc
```

### 2. Circuit Visualization v·ªõi Custom Styling

```python
def create_styled_circuit():
    """T·∫°o circuit v·ªõi custom styling"""
    qc = QuantumCircuit(3, 3)
    qc.h(0)
    qc.cx(0, 1)
    qc.cx(1, 2)
    qc.ry(np.pi/3, 0)
    qc.rz(np.pi/4, 1)
    qc.measure([0, 1, 2], [0, 1, 2])
    
    return qc

def plot_with_custom_style():
    """Plot circuit v·ªõi custom style"""
    qc = create_styled_circuit()
    
    # Custom style
    style = {
        'backgroundcolor': '#002b36',
        'plotter': 'mpl',
        'style': 'iqp',
        'fold': 20
    }
    
    return qc, style
```

## üî¨ Th·ª±c h√†nh v√† Th√≠ nghi·ªám

### B√†i t·∫≠p 1: T·∫°o Quantum Fourier Transform Module

```python
def qft_module(n_qubits):
    """T·∫°o QFT module c√≥ th·ªÉ t√°i s·ª≠ d·ª•ng"""
    qc = QuantumCircuit(n_qubits, n_qubits)
    
    for i in range(n_qubits):
        qc.h(i)
        for j in range(i+1, n_qubits):
            qc.cp(np.pi/2**(j-i), i, j)
    
    # Swap qubits
    for i in range(n_qubits//2):
        qc.swap(i, n_qubits-1-i)
    
    return qc

def inverse_qft_module(n_qubits):
    """T·∫°o inverse QFT module"""
    qc = QuantumCircuit(n_qubits, n_qubits)
    
    # Swap qubits first
    for i in range(n_qubits//2):
        qc.swap(i, n_qubits-1-i)
    
    for i in range(n_qubits-1, -1, -1):
        for j in range(n_qubits-1, i, -1):
            qc.cp(-np.pi/2**(j-i), i, j)
        qc.h(i)
    
    return qc
```

### B√†i t·∫≠p 2: Parameterized Ansatz

```python
def create_ansatz(n_qubits, depth):
    """T·∫°o parameterized ansatz cho VQE"""
    qc = QuantumCircuit(n_qubits, n_qubits)
    
    # T·∫°o parameters
    params = []
    for d in range(depth):
        for i in range(n_qubits):
            theta = Parameter(f'Œ∏_{d}_{i}')
            phi = Parameter(f'œÜ_{d}_{i}')
            params.extend([theta, phi])
    
    param_idx = 0
    for d in range(depth):
        # Rotation layer
        for i in range(n_qubits):
            qc.ry(params[param_idx], i)
            qc.rz(params[param_idx + 1], i)
            param_idx += 2
        
        # Entanglement layer
        for i in range(n_qubits - 1):
            qc.cx(i, i + 1)
        qc.cx(n_qubits - 1, 0)
    
    return qc
```

### B√†i t·∫≠p 3: Circuit Decomposition

```python
def decompose_to_basis_gates():
    """Decompose custom gate th√†nh basis gates"""
    # T·∫°o custom gate
    custom_matrix = np.array([
        [np.cos(np.pi/8), -1j*np.sin(np.pi/8)],
        [-1j*np.sin(np.pi/8), np.cos(np.pi/8)]
    ])
    
    custom_gate = UnitaryGate(custom_matrix, label='Custom')
    
    qc = QuantumCircuit(1, 1)
    qc.append(custom_gate, [0])
    
    # Decompose
    from qiskit.transpiler import PassManager
    from qiskit.transpiler.passes import Unroller
    
    pm = PassManager()
    pm.append(Unroller(['u1', 'u2', 'u3', 'cx']))
    decomposed_qc = pm.run(qc)
    
    return qc, decomposed_qc
```

## üéØ ·ª®ng d·ª•ng th·ª±c t·∫ø

### 1. Quantum Error Correction Circuit

```python
def create_error_correction_circuit():
    """T·∫°o circuit cho quantum error correction"""
    qc = QuantumCircuit(5, 3)  # 5 qubits, 3 classical bits
    
    # Encode logical qubit
    qc.cx(0, 1)
    qc.cx(0, 2)
    qc.cx(0, 3)
    qc.cx(0, 4)
    
    # Syndrome measurement
    qc.cx(0, 1)
    qc.cx(0, 2)
    qc.cx(0, 3)
    qc.cx(0, 4)
    qc.measure([1, 2, 3], [0, 1, 2])
    
    return qc
```

### 2. Quantum Teleportation v·ªõi Custom Gates

```python
def enhanced_teleportation():
    """Quantum teleportation v·ªõi custom gates"""
    qc = QuantumCircuit(3, 3)
    
    # Prepare state to teleport
    qc.h(0)
    qc.rz(np.pi/6, 0)
    
    # Create Bell pair
    qc.h(1)
    qc.cx(1, 2)
    
    # Teleportation protocol
    qc.cx(0, 1)
    qc.h(0)
    
    # Measure
    qc.measure([0, 1], [0, 1])
    
    # Conditional operations
    qc.cx(1, 2)
    qc.cz(0, 2)
    
    qc.measure(2, 2)
    return qc
```

## üìö B√†i t·∫≠p v·ªÅ nh√†

1. **Custom Gate Library**: T·∫°o th∆∞ vi·ªán 5 custom gates h·ªØu √≠ch
2. **Circuit Optimization**: T·ªëi ∆∞u h√≥a m·∫°ch 10 qubit v·ªõi depth > 50
3. **Parameterized Ansatz**: Thi·∫øt k·∫ø ansatz cho molecular simulation
4. **Visualization Project**: T·∫°o interactive circuit visualizer

## üéØ K·∫øt qu·∫£ mong ƒë·ª£i
- Th√†nh th·∫°o circuit composition v√† modular design
- C√≥ th·ªÉ t·∫°o v√† s·ª≠ d·ª•ng custom gates
- Hi·ªÉu v√† √°p d·ª•ng circuit optimization techniques
- S·ª≠ d·ª•ng advanced visualization tools

## üìñ T√†i li·ªáu tham kh·∫£o
- [Qiskit Circuit Library](https://qiskit.org/documentation/apidoc/circuit_library.html)
- [Qiskit Transpiler](https://qiskit.org/documentation/apidoc/transpiler.html)
- [Custom Gates in Qiskit](https://qiskit.org/textbook/ch-gates/standard-gates.html) 